Specification "pts".

Define name : tm -> prop by
  nabla x, name x.

Define ctx_r : olist -> prop by
  ctx_r nil;
  nabla x, ctx_r (of x T :: wf x :: G ) := ctx_r G /\ exists K, {G |- of T K} .

Define is_of : o -> prop by
  nabla x, is_of (of x T);
  nabla x, is_of (wf x).

Define ctx_wf : olist -> prop by
  ctx_wf nil;
  nabla x, ctx_wf (wf x::G) := ctx_wf G.

Define is_wf : o -> prop by
  nabla x, is_wf (wf x).

Theorem member_of_name : forall G E, ctx_r G -> member E G -> is_of E.
induction on 2. intros. case H2.
case H1. search. case H1. case H3.
search.
apply IH to _ H6. search.

Theorem member_wf : forall G E, ctx_wf G -> member E G -> is_wf E.
induction on 2. intros. case H2. case H1. search.
case H1. apply IH to _ H3. search.

Theorem mem_of_wf : forall G M T , ctx_r G -> member (of M T) G -> member (wf M) G.
induction on 2. intros. case H2. case H1. search.
case H1. case H3. apply IH to _ H6. search.

Theorem kinds' : forall G M T, ctx_r G -> member (of M T) G -> exists K, {G |- of T K}.
induction on 2. intros. case H2.
case H1. search. case H1. case H3.
apply IH to _ H6.
search.

Define append : olist -> olist -> olist -> prop by
 append nil Ys Ys;
 append (X::Xs) Ys (X::Zs) := append Xs Ys Zs.

Theorem append_member : forall L M N E, append L M N -> member E N -> member E L \/ member E M.
induction on 1. intros. case H1. search.
case H2. search.
apply IH to H3 H4. case H5. search. search.

Theorem append_member_l : forall L M N E, append L M N -> member E L -> member E N.
induction on 1. intros. case H1. case H2.
case H2. search. apply IH to H3 H4. search.

Theorem append_member_r : forall L M N E, append L M N -> member E M -> member E N.
induction on 1. intros. case H1. search.
apply IH to H3 H2. search.

Theorem weaken_several : forall G G' G'' M T, append G G' G'' -> {G' |- of M T} -> {G'' |- of M T}.
induction on 1. intros. case H1. search.
apply IH to H3 H2. search.

Theorem weaken_several_eq : forall G G' G'' M N, append G G' G'' -> {G' |- eq M N} -> {G'' |- eq M N}.
induction on 1. intros. case H1. search.
apply IH to H3 H2. search.

Theorem member_prune : forall G E, nabla (n:tm),
 member (E n) G -> (exists E', E = x\E').
induction on 1. intros. case H1. search.
apply IH to H2. search.

% This appears to be the only theorem that depends on what we take for "axioms" of the PTS
Theorem axiom_strengthen : forall G D S1 S2, ctx_r G -> {G |- axiom S1 S2} -> {D |- axiom S1 S2}.
intros. case H2. apply member_of_name to _ H3. case H4.
search.

% This appears to be the only theorem that depends on what we take for "rules" of the PTS.
Theorem rule_strengthen : forall G D S1 S2 S3, ctx_r G -> {G |- rule S1 S2 S3} -> {D |- rule S1 S2 S3}.
intros. case H2. apply member_of_name to _ H3. case H4.
search. search. search. search.

Theorem member_fresh_append : forall G G' G'' U T, nabla x, ctx_r (G'' x) -> append (G' x) (of x U::G) (G'' x) -> member (of x T) (G' x) -> false. 
induction on 2. intros. case H2. case H3.
case H1. case H3.
case H4.
case H7.
apply IH to _ H8 H9.
case H4.
assert (member (of n1 U) (of n1 U :: G)).
apply append_member_r to H7 H8.
apply member_prune to H9.



